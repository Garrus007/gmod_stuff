@name flying_baths
@inputs W S A D
@outputs 
@persist MovePID:table RotPID:table
@trigger 


interval(10)

Me = entity()
Base = Me:isWeldedTo()
Player = owner()

##############################################################
# PID
##############################################################

function table init_pid(P:number, I:number, D:number)
{
    local PID = table()
    PID["P_gain", number] = P
    PID["I_gain", number] = I
    PID["D_gain", number] = D
    return PID
}

function number calc_pid(PID:table, X:number, X0:number) {
    local Err = X - X0
    
    # P
    local P_Term = PID["P_gain", number] * Err
    
    # I
    local I_state = PID["I_state", number]
    I_state += Err
    I_state = min(I_state, PID["I_max", number])
    I_state = max(I_state, PID["I_min", number])
    PID["I_state", number] = I_state
    local I_Term = PID["I_gain", number] * I_state
    
    # D
    local D_Term = PID["D_gain", number] * (X - PID["D_state", number])
    PID["D_state", number] = X
    
    return P_Term + I_Term - D_Term 
}

function table init_pid_3d(P:number, I:number, D:number)
{
    local PID = table()
    PID["X", table] = init_pid(P, I, D)
    PID["Y", table] = init_pid(P, I, D)
    PID["Z", table] = init_pid(P, I, D)
    return PID
}

function vector calc_pid_3d(PID:table, X:vector, X0:vector)
{
    local PX = calc_pid(PID["X", table], X:x(), X0:x())
    local PY = calc_pid(PID["Y", table], X:y(), X0:y())
    local PZ = calc_pid(PID["Z", table], X:z(), X0:z())
    return vec(PX, PY, PZ)
}

##############################################################
# MAIN
##############################################################

function setup()
{
    print("Setup")
    #MovePID = init_pid_3d(1, 0, 0)
    #RotPID = init_pid_3d(50000, 0, -30000)
    RotPID = init_pid_3d(10000, 0, -100000)
}

function loop()
{

    # Rotation control
    # Calculate torque for Yaw, Pitch, Roll using PID-controller
    # Angles used as error values
    
    # Yaw error
    # Just bearing - signed angle between Base forward direction and target position
    #                in horizontal plane
    local YawErr = -Base:bearing(Player:pos())
    
    # Pitch error
    # Just bearing - signed angle between Base forward direction and target position
    #                in vertical error
    local PitchErr = -Base:elevation(Player:pos())
    
    # Roll error
    # This is quite difficult
    # Use angle between "ideal" up vector (without any roll) and real up vector (with roll)
    #
    # "ideal" up vector calculation
    # Ref: https://learnopengl.com/Getting-started/Camera
    local Right = vec(0, 0, 1):cross(Base:eye())
    local Up0 = Base:eye():cross(Right)
    # Convet up0 to the local frame. Real up in local frame is always (0, 0, 1)
    # Local up0 is always (0, y, z) (TODO: Proof), so just use atan2 to calc angle
    # This is close to Bearing calculation in E2 standart function
    Up0 = Base:toLocalAxis(Up0)
    local Up = vec(0, 0, 1)
    local RollErr = -atan(Up0:y(), Up0:z())
    
    # Control
    local Rot = vec(RollErr, PitchErr, YawErr)
    local Rot0 = vec(0, 0, 0)
    local Torque = calc_pid_3d(RotPID, Rot, Rot0)
    Base:applyTorque(Torque)
}

if(first()) {
    setup()
}
else {
    loop()
}
